\documentclass[12pt]{article}

\usepackage[a4paper, top=2.5cm, right=2.5cm, bottom=2.5cm, left=2.5cm]{geometry}
\usepackage{listings}
\usepackage{setspace}

\onehalfspace
% Later references:
% - https://pages.cs.wisc.edu/~horwitz/CS704-NOTES/1.LAMBDA-CALCULUS.html
% - https://en.wikipedia.org/wiki/Lambda_calculus
% - https://en.wikipedia.org/wiki/De_Bruijn_index

\title{A lambda calculus compiler}
\author{Áron Hárnási \\ \normalsize Eötvös Lóránd University, Faculty of Informatics}

\lstdefinestyle{mystyle}{
    basicstyle=\ttfamily,
}

\lstset{style=mystyle}

\begin{document}
\linespread{1}
\maketitle
\pagebreak
\tableofcontents
\pagebreak

\section{Introduction}

This is the user and development documentation of a compiler that compiles a
language inspired by simply typed lambda calculus, and produces C source code.

\subsection{Lambda calculus}

Lambda calculus is a mathematical system in which we are able to define any
computation that can be defined with a Turing machine. This is achieved using
function application and substitution on lambda terms. A lambda term in the
simplest form of lambda calculus is built up of three parts:
\begin{itemize}
    \item $(x)$ A variable that can hold a value.
    \item $(\lambda x. F)$ A lambda that can represent a function, where $x$
        is the function parameter and $F$ is another term, that may or 
        may not contain $x$.
    \item $(f\:a)$ A function application where $f$ is the function $a$ is
        applied to. Both $f$ and $a$ are terms. \\ \textbf{Note:} Since variable
        terms can also be denoted with a string of characters, it is important
        to put a space between the two terms to distinguish between a function
        application and a variable term.
\end{itemize}
The main reduction operation is $\beta$-reduction. With $\beta$-reduction, we
can reduce a function application from the form $(\lambda x. F)\:A$ to the
form $F[x := (A)]$, where the $F[x := (A)]$ denotes a new term that is the same
as $F$ except each $x$ variable is replaced with the $(A)$ term.

$\beta$-reduction in this form, can introduce naming collisions in the system.
For example, the term $((\lambda x. (\lambda y. x)) y) z$ would reduce to
$(\lambda y. y) z$ and then $z$. If we instead used $w$ for the parameter of the
inner lambda, $((\lambda x. (\lambda w. x)) y) z$ would reduce to $(\lambda w.
y) z$ and then $y$, which is different from the first scenario.

In order to avoid naming collisions, we can use the $\alpha$-reduction rule.
With $\alpha$-reduction, we can rename variables in a given lambda calculus
term. Renaming can be used before a $\beta$-reduction, for example, in the
previous example $((\lambda x. (\lambda y. x)) y) z$ replacing $y$ with $w$ in
the inner lambda term will result in $((\lambda x. (\lambda w. x)) y) z$, which
does not have naming collisions.

\subsubsection{De Bruijn indexing}

One other way of eliminating naming collisions is the use of De Bruijn indexing.
Bound variables can be represented not with names given to them at the start of
a lambda term, but instead with numbers denoting how far the variable occurrence
is compared to the lambda term that the variable is bound to. For example, the
term $(\lambda x. (\lambda y. x))$ with De Bruijn indices would be $\lambda
\lambda 2$, or the term $(\lambda y. (\lambda z. ((\lambda x. (\lambda y. x)) y)
z))$, part of which was used in the previous paragraph, would be $\lambda
\lambda ((\lambda \lambda 2) 2) 1$. Using De Bruijn indexing eliminates naming
collisions, and it is used in this thesis as an alternative to
$\alpha$-reduction.

\subsection{This implementation}

In this section, we will touch on the most important differences between the
formal system of lambda calculus, and this implementation. There have been a lot
of ideas borrowed from C, Rust, and Haskell in order to make the language usable
from a non-theoretical standpoint.

\subsubsection{Global variables}

In order to make the language more usable, much like in Haskell, it is possible
to create global definitions for terms, that can be used in other parts of the
program. This introduces recursion as the main fix-point combinator.

\subsubsection{Static typing}

It was decided, that the code this compiler compiles from was going to be
statically typed. Each term has a type that is assigned to it at compile time by
a type inference algorithm. Types of global variables can also be specified, in
which case the compiler checks if it matches the inferred type of the same
variable.

\subsubsection{Garbage collection}

There is a simple garbage collection algorithm built into the runtime of the
generated code. The algorithm uses a mark-and-sweep style method to find and
free allocated memory that is not used.

\subsubsection{Impure C back-end}

The target language of the compiler is C; therefore there are functions and
primitive types in the source language that have a corresponding pair in the
target language. For example, number types, certain operations on them, and
several input-output functions. \\ \textbf{Note:} The IO functions are not handled in
the way Haskell handles IO. The IO functions in this source language are impure
functions.

\section{User documentation}

\subsection{Building the software}
\subsubsection{Dependencies}

To build the program one would require the following packages:
\begin{itemize}
    \item git
    \item stack v2.11.1 or later
    \item ghc v9.4.8 or later \\ Note that with default settings stack usually
        downloads the appropriate ghc version for the project.
\end{itemize}
Note that the compiler was only tested on a few Linux distributions, and it is
possible that it does not work properly on some others. Using Ubuntu 22.04
should work. It is also recommended, that the Haskell tools are installed via
ghcup. Alternatively, the repository is also set up to be built on NixOS, which
might be a better choice in case it fails on Ubuntu.

\subsubsection{Compilation and installation}

If all the necessary dependencies are present, building the project should only
require two steps. To build the project, execute the following commands in an
appropriate directory.
\begin{lstlisting}
$ git clone --depth=1 \
    https://github.com/ConcreteCactus/lambda-compiler.git
\end{lstlisting}
This will clone the repository, which is hosted on GitHub. In order to build and
install the compiler, one would run the following:
\begin{lstlisting}
$ cd lambda-compiler
$ stack install
\end{lstlisting}
This will build and install the required dependencies, including ghc. The
compiler binary is usually copied to \texttt{\$HOME/.local/bin}. Please, make
sure the resulting binary is on the \texttt{PATH}. If the installation goes
correctly, running \texttt{lcc -v} should show a banner similar to the
following:
\begin{lstlisting}
$ lcc -v
lambda_compiler v1.0

___
\_ \
  \ \       __     __       __     __
   \ \     (_ \   / _)     (_ \   / _)
   /  \      \ \_/ /         \ \_/ /
  / /\ \      ) _ (           ) _ (
 / /  \ \   _/ / \ \_       _/ / \ \_
/_/    \_\ (__/   \__) (_) (__/   \__)
\end{lstlisting}
\textbf{Note:} Throughout this document, the compiler is referred to by the name
\texttt{lcc} and its input language is referred to by the name LC.

\subsubsection{Runtime dependency}

In order to compile an executable, \texttt{lcc} uses \texttt{gcc} by default.
Therefore it is recommended, to have an installed version of \texttt{gcc} on the
\texttt{PATH}. The version \texttt{lcc} was tested with was gcc v11.4.0, however
it is likely that compilation works on older versions as well. Alternatively, it
is possible to specify a different C compiler with command-line arguments, which
will be discussed under Command-line options.

\subsection{Running the compiler}

The main job of the compiler is converting from LC source code to C source code.
Once it has the C source file, it is compiled to binary using \texttt{gcc} if no
other command-line option is specified. The file extension of the input file
does not matter, however in this document they will be referred to with the
extension \texttt{.lc}. To simply compile an input file, one would run the
following:
\begin{lstlisting}
$ lcc hello.lc
\end{lstlisting}
This command compiles the input file \texttt{hello.lc} and produces a binary
file with the default name \texttt{gcc} gives to output binaries. On Linux it is
usually \texttt{a.out}. \texttt{lcc} produces a \texttt{.c} file containing the
source code it has generated as well with the default name \texttt{a.c}.

\subsubsection{Command-line options}

It is possible to give command-line options to the compiler in order to alter
its behavior. 

\vspace{7pt}

\begin{tabular}{l l}
    \texttt{-n}\quad& Do not run any C compiler, only compile from \\ 
                    & LC to C. \\
    \texttt{-v}\quad& Show version and about information and exit. \\
    \texttt{-h}\quad& Print some help text and exit. \\
    \texttt{-o <output-exe>}\quad& Specify the name of the executable
        generated. \\
    \texttt{-O <output.c>}\quad& Specify the name of the C source generated. \\
    \texttt{-c <cc>}\quad& Specify the C compiler command.
\end{tabular}

\vspace{8pt}

\textbf{Note:} When using \texttt{-n} and \texttt{-o} and/or \texttt{-c} together,
no C compiler will be run. Also note that when using \texttt{-v} or \texttt{-h},
no compilation of any kind will be performed. 

\subsection{The LC language}

The LC language is a language inspired by simply typed lambda calculus.
Expressions are similar to lambda calculus terms, they are simply typed, and
types support parametric polymorphism. In this subsection, the key details of
the language will be discussed.

\subsubsection{Syntax and semantics}

Syntactically, the language has several similarities to Haskell. Global
variables can be defined with the \texttt{:=} operator in the following way.
\begin{lstlisting}
globalVariable := expression
\end{lstlisting}
Optionally, any global variable can have its type specified. For each specified
type, the compiler checks if it can be used in place of the inferred type. To
specify the type of a global variable, one would use the \texttt{:} operator in
the following way:
\begin{lstlisting}
globalVariable : I32 -> I32 -> I32
globalVariable := expression
\end{lstlisting}
In this case, \verb$globalVariable$ is a function that takes two 32bit signed
integer parameters, and outputs a 32bit signed integer.

\subsubsection{The syntax of expressions}

All expressions consist of six parts:
\begin{itemize}
    \item Variables
    \item Lambdas
    \item Applications
    \item Global references
    \item If expressions
    \item Literals
\end{itemize}

\paragraph{Variables} Variables always represent function parameters. They can
be denoted with a single ASCII character, or a string of ASCII characters. Their
first character is always lower-case. For example, \verb$x$ or \verb$exampleVar$.

\paragraph{Lambdas} Lambdas represent functions. Lambdas have an expression
body, and a parameter. Their parameter can be used inside their expression
body. To create a lambda, one would write a backslash (\verb$\$) character
followed by the parameter name, a dot (\verb$.$), and the expression body. For
example, \verb$\x.x$ or \verb$\a.(f a) g$.

\paragraph{Applications} Applications represent calling functions. Applications
always contain two expressions, The first of which is the function getting
called and the second represents the parameter given to that function. To apply
an expression to another in the LC language, one would write the function to be
called first and the parameter second separated by white-space. For example,
\verb$func param$ or \verb$func param1 param2$.
\noindent
Note that function application is left-associative.

\paragraph{Global references} Global references denote expressions defined
somewhere else in the file. When evaluated, these references are
substituted\footnote{On the compiler level, this substitution is implemented as
    a function call, which happens in a new scope; therefore it is not possible
    to have, for example, free variables in global definitions.} with the
corresponding global definitions. Global references are written in the same way
as local variables; therefore in name-collisions, the local variable will take
precedence.

\paragraph{If expressions} If expressions represent the control-flow if
primitive used in procedural languages. If expressions take three expressions:
one that evaluates to a boolean, one that is used when the boolean is true, and
one that is used when the boolean is false. If expressions are lazy, which makes
it possible to use them in recursive functions when other lazy constructs are
not available or necessary. \\
For example, \verb$if condition then exprIfTrue else exprIfFalse$

\paragraph{Literals} Literals represent number values in the C back-end, on
which the standard library provides basic operations. The following table shows
the possible types they can have and their corresponding C type in the LC
language.
\begin{center}
\begin{tabular}{c c c}
    LC type & Type postfix & C type \\
    \hline
    \verb$I8$ to \verb$I128$ & \verb$i8$ to \verb$i128$ & \verb$int8_t$ to
    \verb$int64_t$ and \verb$__int128$ \\
    \verb$U8$ to \verb$U128$ & \verb$u8$ to \verb$u128$ & \verb$uint8_t$ to
    \verb$uint64_t$ and \verb$unsigned __int128$ \\
    \verb$F32$ and \verb$F64$ & \verb$f32$ and \verb$f64$ & \verb$float$ and
    \verb$double$ \\
    \verb$USize$ & \verb$usize$ & \verb$size_t$ \\
    \verb$Char$ & \verb$char$ & \verb$char$ \\
    \verb$Bool$ & \verb$bool$ & \verb$bool$
\end{tabular}
\end{center}
There are four different ways to write literals. To write a character literal,
one would write the desired character between two single quotes. Escape
sequences are not supported. For example, \verb$'a'$ or \verb$' '$.

With the exception of characters, in the LC language, it is required to use a
type specifying postfix when writing literals. To write a hexadecimal number,
one would prefix it with \verb$0x$ and write the desired value with the
characters \verb$0$-\verb$9$ and \verb$a$-\verb$f$. Hexadecimal numbers need to
be postfixed with an underscore (\verb$_$) and the desired type postfix shown in
the table above. Only unsigned integers, characters, and booleans can be written
in this form. For example, \verb$0x1_u8$ or \verb$0xdeadbeef_u32$.

In order to write a floating point number, one would write the whole part of the
number in decimal form, optionally include the fractional part separated by a
dot (\verb$.$) character, then write the postfix \verb$f32$ or \verb$f64$. For
example, \verb$0f32$ or \verb$3.14f64$.

Decimal numbers can be written similarly to floating point ones with the
exception that decimal numbers can not have a fractional part. Decimal numbers
can be postfixed with all type postfixes except \verb$f32$ and \verb$f64$. For
example, \verb$42u32$ or \verb$-1i8$.

\subsubsection{The syntax of types}
\subsubsection{Standard library}
\subsubsection{Compilation errors}

\subsubsection{A note on white-space}

The language is white-space sensitive; therefore a global variable definition
has to start at the start of the line. An expression can be broken down into
multiple lines so long as there is at least one white-space character at the
start of the next line. For example:
\begin{verbatim*}
adder := \a. \b.
 add_i32 a
         b
nextDefinition := nextExpression
\end{verbatim*}

\section{Developer documentation}
\end{document}
