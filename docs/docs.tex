\documentclass[12pt]{article}

% Later references:
% - https://pages.cs.wisc.edu/~horwitz/CS704-NOTES/1.LAMBDA-CALCULUS.html
% - https://en.wikipedia.org/wiki/Lambda_calculus
% - https://en.wikipedia.org/wiki/De_Bruijn_index

\title{A lambda calculus compiler}
\author{Áron Hárnási \\ \normalsize Eötvös Lóránd University, Faculty of Informatics}

\begin{document}
\maketitle
\pagebreak
\tableofcontents
\pagebreak

\section{Introduction}
\subsection{Lambda calculus}

Lambda calculus is a mathematical system in which we are able to define any
computation that can be defined with a Turing machine. This is achieved using
function application and substitution on lambda terms. A lambda term in the
simplest form of lambda calculus is built up of three parts:
\begin{itemize}
    \item $(x)$ A variable that can hold a value.
    \item $(\lambda x. F)$ A lambda that can represent a function, where $x$
        is the function parameter and $F$ is another term, that may or 
        may not contain $x$.
    \item $(f\:a)$ A function application where $f$ is the function $a$ is
        applied to. Both $f$ and $a$ are terms. Note that since variable terms
        can also be denoted with a string of characters, it is important to put
        a space between the two terms to distinguish between a function
        application and a variable term.
\end{itemize}
The main reduction operation is $\beta$-reduction. With $\beta$-reduction, we
can reduce a function application from the form $(\lambda x. F)\:A$ to the
form $F[x := (A)]$, where the $F[x := (A)]$ denotes a new term that is the same
as $F$ except each $x$ variable is replaced with the $(A)$ term.

$\beta$-reduction in this form, can introduce naming collisions in the system.
For example, the term $((\lambda x. (\lambda y. x)) y) z$ would reduce to
$(\lambda y. y) z$ and then $z$. If we instead used $w$ for the parameter of the
inner lambda, $((\lambda x. (\lambda w. x)) y) z$ would reduce to $(\lambda w.
y) z$ and then $y$, which is different from the first scenario.

In order to avoid naming collisions, we can use the $\alpha$-reduction rule.
With $\alpha$-reduction, we can rename variables in a given lambda calculus
term. Renaming can be used before a $\beta$-reduction, for example, in the
previous example $((\lambda x. (\lambda y. x)) y) z$ replacing $y$ with $w$ in
the inner lambda term will result in $((\lambda x. (\lambda w. x)) y) z$, which
does not have naming collisions.

\subsubsection{De Bruijn indexing}

One other way of eliminating naming collisions is the use of De Bruijn indexing.
Bound variables can be represented not with names given to them at the start of
a lambda term, but instead with numbers denoting how far the variable occurrence
is compared to the lambda term that the variable is bound to. For example, the
term $(\lambda x. (\lambda y. x))$ with De Bruijn indices would be $\lambda
\lambda 2$, or the term $(\lambda y. (\lambda z. ((\lambda x. (\lambda y. x)) y)
z))$, part of which was used in the previous paragraph, would be $\lambda
\lambda ((\lambda \lambda 2) 2) 1$. Using De Bruijn indexing eliminates naming
collisions, and it is used in this thesis as an alternative to
$\alpha$-reduction.

\subsection{This implementation}

In this section, we will touch on the most important differences between the
formal system of lambda calculus, and this implementation. There have been a lot
of ideas borrowed from C and Haskell in order to make the language usable from a
non-theoretical standpoint.

\subsubsection{Global variables}

In order to make the language more usable, much like in Haskell, it is possible
to create global definitions for terms, that can be used in other parts of the
program. This introduces recursion as the main fix-point combinator.

\subsubsection{Static typing}

It was decided, that the code this compiler compiles from was going to be
statically typed. Each term has a type that is assigned to it at compile time by
a type inference algorithm. Types of global variables can also be specified, in
which case the compiler checks if it matches the inferred type of the same
term.

\subsubsection{Garbage collection}

There is a simple garbage collection algorithm built into the runtime of the
generated code. The algorithm uses a mark-and-sweep style method to find and
free allocated memory that is not used.

\subsubsection{Impure C back-end}

The target language of the compiler is C, therefore there are functions and
primitive types in the source language that have a corresponding pair in the
target language. For example, number types and certain operations on them and
several input-output functions. Note, that the IO functions are not handled in
the way Haskell handles IO. The IO functions in this source language are impure
functions.

\section{User documentation}
\subsubsection{Recursion ??}
\section{Developer documentation}
\end{document}
